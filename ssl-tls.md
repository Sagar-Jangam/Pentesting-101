# SSL/ TLS

Till this point, communication between Alice's server and Bob's client took place in clear-text format. Which, if intercepted by any party could expose information flowing between the two. While working on the government project \(which involved authentication and flow of sensitive information\), Alice realized the shortcomings of the clear-text flow of traffic. Though the government system was in their local network and an outsider couldn't simply intercept the traffic, which wasn't the case with Alice's website. Thus Alice thought of transmitting data in an encrypted format and implemented Secure Socket Layer \(SSL\). SSL, the predecessor to TLS, was an encryption protocol on top of HTTP, together they are called HTTPS \(or HTTP over SSL/ TLS\).

As SSL was implemented on top of HTTP, it is possible to encrypt the entire data exposed by HTTP. However, TCP uses the IP address and port number to make a connection thus IP and Port can't be encrypted. A common practice is to leave the domain \(or IP address, if used\) and port out of encryption scope. On the other hand, the rest of the data including URL \(baring domain and port\), Query string, Path, Headers, and Body are encrypted in transit.

For using encryption in transit, the data should be encrypted and decrypt at both ends of the communication. And keeping in mind the intention \(integrity and confidentiality of the data\) Alice came up with a combination of Symmetric and Asymmetric encryption. Asymmetric encryption is used initially for authentication, further symmetric encryption is used for data transfer \(We will look at this in detail in the "Handshake" section\).

Asymmetric encryption means that encryption and decryption of data need two different keys. In the case of HTTPS, the server keeps one of the keys "the private key" with itself and shares the other one with everyone visiting the website "the public key". This allows only the server to decrypt data sent from the client. As asymmetric encryption is only used in the initial authentication process, the client doesn't need to have/ share keys for asymmetric encryption \(there are use cases where the client also shares their keys\). Though the server shares its public keys, this can in no way authenticates the server, as anybody on the internet can create a set of public/ private keys. The server has to share more information which is then verified by the client with an independent third party.

The server shares all the necessary information in its SSL/ TLS certificate, and the third party to verify the authenticity of the server is called a Certificate Authority. Lets look at these and related terms in brief.

## SSL/ TLS Certificate

An SSL/ TLS certificate is a standard defined \(x.509\) collection of data that is used for verification of identity, ownership of the public key, and encryption/ decryption of data. Among other things, a certificate contains the Public Key of the server and the Distinguished Name for the parent entity \(an organization, an individual\) of the server. It also contains information about the issuer of the certificate.

All this information combined together is used for authentication of server and client in the initial phase \(aka SSL Handshake\) SSL/ TLS communication.

## Certificate Authority

A trusted third-party entity that is responsible for issuing and verifying certificates. During an SSL handshake, a browser asks CAs from a list of CAs to verify the validity and authenticity of a certificate. Only after the verification from a CA, the browser moves ahead with the handshake and further communication.

## SSL Handshake

Now that we have a familiarity with CA and Certificates, let's look at the SSL Handshake. An SSL handshake is dependent on the key exchange algorithm used and cipher suite supported by the client and server, the exact steps involved thus change on the basis of algorithm and cipher suite. Let's look at the steps for RSA key exchange.

![Client and Server exchange for a SSL handshake](https://images.ctfassets.net/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png)

We will just look at the SSL handshake and ignore the TLS messages. 

1. **The 'client hello' message**: The client sends a "hello" message to the server. The message includes the TLS version supported by the client, the cipher suites supported, and a string of random bytes known as the "client random." 

2. **The 'server hello' message**: In reply, the server sends the server's SSL certificate \(including the public key\), the server's chosen cipher suite, and the "server random," another random string of bytes that's generated by the server. The server keeps the private key with itself. 

3. **Authentication**: The client verifies the server's SSL certificate with the CA who issued it. This confirms that the server is who it says it is. 

4. **The premaster secret**: The client sends one more random string of bytes, the "premaster secret." The premaster secret is encrypted with the public key and can only be decrypted with the private key by the server. 

5. **Private key used**: The server decrypts the premaster secret. 

6. **Session keys created**: Both client and server generate session keys from the client random, the server random, and the premaster secret. They should arrive at the same results. 

7. **Client is ready**: The client sends a "finished" message that is encrypted with a session key. 

8. **Server is ready**: The server sends a "finished" message encrypted with a session key. 

9. **Secure symmetric encryption achieved**: The handshake is completed.

Till this point, the server and client uses asymmetric encryption, the client and server further use a symmetric key \(session key\) for encryption and decryption.

### Types of Certificate

Certificates are classified on the basis of the validation performed by the CA before issuing the certificate and the usage of the certificate. 

#### Validations

A CA before issuing a certificate performs validation of the organization/ individual requesting the certificate. CAs want to ensure that the domain is owned by the application and perform validation of different degrees on the identity of the applicant. 

**DV**: Domain Validation, the CA only verifies if the domain is controlled by the applicant or not. The CAs verify this by just request a change in DNS records. 

**OV**: Organization Validation, along with the domain verification, the CA reach out to the application organization and verify the address and email 

**EV**:  Extended Validation, these are the most strict and expensive validations, the CAs ensures that the organization exists, are legally a business, are located where they claim, etc.

#### Self Signed Certificate

A DV certificate, where the certificate is signed by it's own private key, thus bypassing the need of a CA verification. The browser, however, needs to be manually configured to trust the certificate as the certificate is not signed by a known CA. Self signed certificate are sometimes used in phishing campaigns \(we will discuss this in detail\).

#### PKI 

PKI stands for Public Key Infrastructure, it is used to establish and manage a public key encryption. It's components include the CAs, Certificates, Certificate Registrar,  repositories of certificates, etc. 

It is nothing but a fancy term for management of a Public Key encryption. SSL/ TLS encryption is the most common example of a PKI, and everything we have seen above is a part of PKI for HTTPS communication. 



